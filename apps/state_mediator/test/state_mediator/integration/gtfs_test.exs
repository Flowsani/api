defmodule StateMediator.Integration.GtfsTest do
  use ExUnit.Case

  @moduledoc """
  Don't run these tests along with the main ones.  Instead, run them alone:

  `$ mix test --include integration --exclude test`

  You can also give them a direct path to a .ZIP file for local testing:

  `$ env MBTA_GTFS_FILE=<path to GTFS.zip> mix test --include integration --exclude test`
  """
  @moduletag :integration

  # 5 minutes
  @long_timeout :timer.seconds(900)

  setup_all do
    Logger.configure(level: :info)
    maybe_start_bypass!(System.get_env("MBTA_GTFS_FILE"))
    :ok = Events.subscribe({:new_state, State.Shape})
    :ok = Events.subscribe({:new_state, State.RoutesAtStop})
    :ok = Events.subscribe({:new_state, State.StopsOnRoute})
    old_start = Application.get_env(:state_mediator, :start)
    Application.put_env(:state_mediator, :start, true)
    Application.stop(:state_mediator)
    Application.ensure_all_started(:state_mediator)

    on_exit(fn ->
      Application.put_env(:state_mediator, :start, old_start)
      Application.stop(:state_mediator)
    end)

    receive_items(State.RoutesAtStop)
    receive_items(State.Shape)
    receive_items(State.StopsOnRoute)
    Logger.configure(level: :warn)
  end

  defp maybe_start_bypass!(nil) do
    :ok
  end

  defp maybe_start_bypass!(filename) do
    # if a filename was provided, run a fake webserver to provide it
    filename = Path.expand(filename, Application.get_env(:state_mediator, :cwd))
    bypass = Bypass.open()

    Bypass.expect(bypass, fn conn ->
      Plug.Conn.send_file(conn, 200, filename)
    end)

    realtime_config = Application.get_env(:state_mediator, Realtime)
    realtime_config = put_in(realtime_config[:gtfs_url], "http://127.0.0.1:#{bypass.port}")
    Application.put_env(:state_mediator, Realtime, realtime_config)
  end

  # builds configurable tests: see apps/api/config/test.exs
  for {describe_name, module, opts} <- Application.get_env(:state_mediator, GtfsTestModules) do
    describe "#{describe_name} (autogenerated)" do
      if min_size = opts[:minimum_size] do
        test "has at least #{min_size} elements" do
          assert unquote(module).size > unquote(min_size)
        end
      end

      if required_fields = opts[:required_fields] do
        @tag timeout: @long_timeout
        test "all #{describe_name} have required fields" do
          missing_fields = fn item ->
            for {field, {m, f, a}} <- unquote(Macro.escape(required_fields)),
                value = Map.get(item, field),
                valid = apply(m, f, [value | a]),
                valid == false or is_nil(valid) do
              {field, value}
            end
          end

          missing =
            for item <- unquote(module).all,
                field <- missing_fields.(item) do
              {item.id, field}
            end

          assert missing == []
        end
      end
    end
  end

  describe "stops" do
    test "correctly calculates first/last stops on routes" do
      assert_first_last_stop_id("Red", "place-alfcl", "place-brntn")
      assert_first_last_stop_id("CR-Providence", "place-sstat", "Wickford Junction")
      assert_first_last_stop_id("CR-Fairmount", "place-sstat", "Readville")
      assert_first_last_stop_id("CR-Franklin", "place-sstat", "Forge Park / 495")
      assert_first_last_stop_id("CR-Haverhill", "place-north", "Haverhill")
      assert_first_last_stop_id("CR-Lowell", "place-north", "Lowell")
      assert_first_last_stop_id("CR-Kingston", "place-sstat", "Plymouth")
      assert_first_last_stop_id("Green-B", "place-pktrm", "place-lake")
      assert_first_last_stop_id("Green-C", "place-north", "place-clmnl")
      assert_first_last_stop_id("Green-D", "place-gover", "place-river")
      assert_first_last_stop_id("Green-E", "place-lech", "place-hsmnl")
    end

    test "keeps green line core in the correct order" do
      # prefixes and suffixes are for the extended core, which hit some but
      # not all of the 4 lines
      order_prefixes = %{
        "Green-B" => [],
        "Green-C" => ~w(place-north place-haecl place-gover),
        "Green-D" => ~w(place-gover),
        "Green-E" => ~w(place-north place-haecl place-gover)
      }

      order = ~w(place-pktrm place-boyls place-armnl place-coecl)

      order_suffixes = %{
        "Green-B" => ~w(place-hymnl place-kencl),
        "Green-C" => ~w(place-hymnl place-kencl),
        "Green-D" => ~w(place-hymnl place-kencl),
        "Green-E" => []
      }

      for route_id <- ~w(Green-B Green-C Green-D Green-E),
          route_order = order_prefixes[route_id] ++ order ++ order_suffixes[route_id],
          route_order_length = length(route_order),
          date <- dates_of_rating(),
          is_nil(date) or not custom_date?(date),
          direction_id <- [0, 1] do
        route_order =
          if direction_id == 1 do
            Enum.reverse(route_order)
          else
            route_order
          end

        stop_ids =
          for stop <-
                State.Stop.filter_by(%{routes: [route_id], direction_id: direction_id, date: date}),
              do: stop.id

        core_stops =
          stop_ids
          |> Enum.drop_while(&(&1 != List.first(route_order)))
          |> Enum.take(route_order_length)

        assert {route_id, direction_id, route_order} == {route_id, direction_id, core_stops}
      end
    end

    test "only includes place-* stops on rapid transit routes" do
      # makes sure we aren't including random other stops
      routes = State.Route.by_types([0, 1])

      invalid_stops_for_subway = fn stops ->
        stops
        |> Enum.map(& &1.id)
        |> Enum.reject(&String.starts_with?(&1, "place-"))
      end

      invalid_routes =
        for date <- [nil | dates_of_rating()],
            %{id: route_id} <- routes,
            # skip Mattapan for right now
            route_id != "Mattapan",
            direction_id <- [0, 1],
            stops =
              State.Stop.filter_by(%{routes: [route_id], direction_id: direction_id, date: date}),
            invalid_stop_ids = invalid_stops_for_subway.(stops),
            invalid_stop_ids != [] do
          {route_id, date, direction_id, invalid_stop_ids}
        end

      assert invalid_routes == []
    end

    @tag timeout: @long_timeout
    test "each (non-holiday) day of the rating going forward has stops on routes" do
      invalid_routes =
        for date <- dates_of_rating(),
            is_nil(date) or not custom_date?(date),
            %{id: route_id} = route <- all_routes(),
            not exempt_from_testing?(route),
            direction_id <- [0, 1],
            data =
              State.Stop.filter_by(%{routes: [route_id], direction_id: direction_id, date: date}),
            has_unexpected_data?(route_id, date, direction_id, data) do
          {route_id, date, direction_id}
        end

      assert invalid_routes == []
    end

    test "each day has Kingston and Plymouth on CR-Kingston" do
      invalid? = fn stops ->
        ids = Enum.map(stops, & &1.id)
        "Kingston" not in ids or "Plymouth" not in ids
      end

      invalid_dates =
        for date <- dates_of_rating(),
            direction_id <- [0, 1],
            data =
              State.Stop.filter_by(%{
                routes: ["CR-Kingston"],
                direction_id: direction_id,
                date: date
              }),
            invalid?.(data) do
          {date, direction_id}
        end

      assert invalid_dates == []
    end
  end

  describe "shapes" do
    test "outbound highest-priority shape ends at the end of the route" do
      for route_id <- ~w(CR-Haverhill CR-Lowell CR-Worcester Blue Green-E) do
        [primary_shape | _] = State.Shape.select_routes([route_id], 0)
        [last_stop | _] = stops(route_id, 1)
        # don't require an exact match
        assert primary_shape.name =~ last_stop.name
      end
    end

    test "route 9 inbound primary shape is Copley Square" do
      # not the school trip to Boston Latin
      primary_shape = ["9"] |> State.Shape.select_routes(1) |> List.first()
      assert %{name: "Copley Square"} = primary_shape
    end

    test "CR-Lowell inbound has one rail shape" do
      assert [_] =
               ["CR-Lowell"]
               |> State.Shape.select_routes(1)
               |> Enum.reject(&(&1.priority < 0))
    end

    test "Red Line has 2 non-ignored shapes each direction" do
      [shapes_0, shapes_1] = shapes_in_both_directions("Red")
      assert [%{name: "Ashmont"}, %{name: "Braintree"}] = shapes_0
      assert [%{name: "Ashmont"}, %{name: "Braintree"}] = shapes_1
    end

    test "Providence/Stoughton has 2 non-ignored shapes each direction" do
      [shapes_0, shapes_1] = shapes_in_both_directions("CR-Providence")
      assert [%{name: "Providence"}, %{name: "Stoughton"}] = shapes_0
      assert [%{name: "Wickford Junction"}, %{name: "Stoughton"}] = shapes_1
    end

    test "Newburyport/Rockport has 2 non-ignored shapes each direction" do
      [shapes_0, shapes_1] = shapes_in_both_directions("CR-Newburyport")
      assert [%{name: "Rockport"}, %{name: "Newburyport"}] = shapes_0
      assert [%{name: "Rockport"}, %{name: "Newburyport"}] = shapes_1
    end

    test "all shuttle shapes have negative priority" do
      invalid_shapes =
        for shape <- State.Shape.all(), String.ends_with?(shape.id, "-S"), shape.priority >= 0 do
          shape
        end

      assert invalid_shapes == []
    end

    test "each route has only one highest priority shape" do
      for %{id: route_id} <- all_routes(),
          direction_id <- [0, 1] do
        case State.Shape.select_routes([route_id], direction_id) do
          [] ->
            :ok

          [%{priority: priority} | _] when priority < 0 ->
            # highest priority shape is ignored, so don't worry about the others
            :ok

          [shape | rest] ->
            assert Enum.filter(rest, &(&1.priority == shape.priority)) == [],
                   "multiple highest priority shapes on route #{route_id}:#{direction_id}"
        end
      end
    end

    test "each trip has a valid shape" do
      for %{shape_id: shape_id} <- State.Trip.all() do
        assert State.Shape.by_id(shape_id)
      end
    end
  end

  describe "schedules" do
    @tag timeout: @long_timeout
    test "each (non-holiday) day of the rating going forward has service" do
      invalid_schedules =
        for date <- dates_of_rating(),
            not custom_date?(date),
            %{id: route_id} = route <- all_routes(),
            not exempt_from_testing?(route),
            direction_id <- [0, 1],
            data =
              State.Schedule.filter_by(%{
                routes: [route_id],
                direction_id: direction_id,
                date: date
              }),
            has_unexpected_data?(route_id, date, direction_id, data) do
          {route_id, date, direction_id}
        end

      assert invalid_schedules == []
    end

    @tag timeout: @long_timeout
    test "each holiday day of the rating has service on all-week routes" do
      {:ok, feed} = State.Feed.get()
      next_sunday = Timex.end_of_week(feed.start_date)

      invalid_schedules =
        for %{id: route_id} = route <- all_routes(),
            not State.Route.hidden?(route),
            # ignore ferries for now, since they run on Sundays but not all holidays
            route.type != 4,
            # CR-Foxboro has some Sunday service, but not every Sunday
            route.id != "CR-Foxboro",
            direction_id <- [0, 1],
            # make sure it has sunday service
            valid_schedule?(route_id, next_sunday, direction_id),
            date <- dates_of_rating(),
            custom_date?(date),
            State.Schedule.filter_by(%{routes: [route_id], direction_id: direction_id, date: date}) ==
              [] do
          {route_id, date, direction_id}
        end

      assert invalid_schedules == []
    end

    test "each trip has schedules" do
      for %{id: trip_id} <- State.Trip.all() do
        data = State.Schedule.filter_by(%{trips: [trip_id]})
        refute {trip_id, []} == {trip_id, data}
      end
    end

    test "each day has trips" do
      for date <- dates_of_rating() do
        service_ids = State.ServiceByDate.by_date(date)

        matchers =
          for service_id <- service_ids do
            %{service_id: service_id}
          end

        refute State.Trip.select(matchers) == []
      end
    end

    test "CR-Lowell has a trip to Haverhill" do
      refute State.Trip.match(
               %{route_id: "CR-Lowell", direction_id: 0, headsign: "Haverhill"},
               :route_id
             ) == []
    end

    test "CR-Fairmount has alternate route trips" do
      refute State.Trip.match(
               %{route_id: "CR-Fairmount", direction_id: 1, alternate_route: true},
               :route_id
             ) == []
    end
  end

  describe "alerts" do
    test "informed entity IDs match something in state" do
      missing_alert_value = fn {key, value} ->
        case key do
          :route_type ->
            value < 0 or value > 4

          :route ->
            is_nil(State.Route.by_id(value))

          :stop ->
            is_nil(State.Stop.by_id(value))

          :trip ->
            is_nil(State.Trip.by_id(value))

          :facility ->
            is_nil(State.Facility.by_id(value))

          _ ->
            false
        end
      end

      missing_values =
        for alert <- State.Alert.all(),
            entity <- alert.informed_entity,
            key_value <- entity,
            missing_alert_value.(key_value) do
          {alert.id, key_value}
        end

      assert missing_values == []
    end

    test "all alerts with trips have route type, route, and direction_id" do
      missing_values = fn entity ->
        for expected <- [:route_type, :route, :direction_id], nil == Map.get(entity, expected) do
          expected
        end
      end

      missing_data =
        for alert <- State.Alert.all(),
            %{trip: trip_id} = entity <- alert.informed_entity,
            missing <- missing_values.(entity) do
          {alert.id, trip_id, missing}
        end

      assert missing_data == []
    end

    test "all alerts with routes have route type" do
      missing_data =
        for alert <- State.Alert.all(),
            %{route: _route_id} = entity <- alert.informed_entity,
            Map.get(entity, :route_type) == nil do
          alert.id
        end

      assert missing_data == []
    end
  end

  describe "predictions" do
    test "have valid route, trip and stop IDs" do
      for %{route_id: route_id} <- all_routes(),
          prediction <-
            State.Prediction.select_grouped([State.Prediction, State.Prediction.GreenLine], [
              %{route_id: route_id}
            ]) do
        assert State.Route.by_id(prediction.route_id)
        assert State.Trip.by_primary_id(prediction.trip_id)
        assert State.Stop.by_id(prediction.stop_id)
      end
    end
  end

  describe "vehicles" do
    test "have valid route, trip and stop IDs" do
      for %{route_id: route_id} <- all_routes(),
          vehicle <- State.Vehicle.by_effective_route_id(route_id) do
        assert State.Route.by_id(vehicle.route_id)
        assert State.Trip.by_primary_id(vehicle.trip_id)
        assert State.Stop.by_id(vehicle.stop_id)
      end
    end
  end

  @weekday_saturday_only_routes ~w(
    CR-Needham
    5
    7
    14
    18
    29
    33
    37
    38
    51
    62
    65
    70A
    74
    76
    92
    132
    210
    212
    411
    430
    436
    465
    504
    553
    716
  )
  @weekday_only_routes ~w(
    4
    19
    52
    57A
    67
    68
    79
    84
    85
    114
    121
    131
    170
    217
    221
    245
    325
    326
    351
    352
    354
    424
    428
    434
    439
    448
    449
    451
    456
    459
    501
    502
    503
    505
    554
    556
    558
    701
    708
    710
    747
  )

  defp has_unexpected_data?(route_id, date, direction_id, data) do
    if valid_schedule?(route_id, date, direction_id) do
      data == []
    else
      data != []
    end
  end

  defp valid_schedule?("210", date, direction_id) do
    # 210 should only be valid weekday and saturday.  For the moment, it
    # has an outbound-only service on sunday.
    if direction_id == 1 do
      Date.day_of_week(date) != 7
    else
      true
    end
  end

  defp valid_schedule?("CR-Needham", date, _direction_id) do
    # Needham line is suspended on Saturdays between 2017-09-02 and
    # 2017-10-28. It never has service on Sunday.
    if Date.compare(~D[2017-09-01], date) == :gt or Date.compare(~D[2017-10-27], date) == :lt do
      Date.day_of_week(date) != 7
    else
      weekday?(date)
    end
  end

  defp valid_schedule?("Boat-F1", date, _direction_id) do
    if Date.compare(~D[2018-10-08], date) == :lt do
      # weekday only service after Columbus Day
      weekday?(date)
    else
      true
    end
  end

  defp valid_schedule?(id, date, _direction_id) when id in @weekday_saturday_only_routes do
    # No service on Sunday
    Date.day_of_week(date) != 7
  end

  defp valid_schedule?(id, date, direction_id) when id in ~w(136 137) do
    if Date.day_of_week(date) == 7 do
      # on Sunday, the 136 is only outbound and the 137 is only inbound
      {id, direction_id} in [{"136", 0}, {"137", 1}]
    else
      true
    end
  end

  defp valid_schedule?(id, date, direction_id) when id in ~w(214) do
    if weekday?(date) do
      true
    else
      # On weekends, only outbound service
      direction_id == 0
    end
  end

  defp valid_schedule?("171", _, 1) do
    # only outbound trips
    false
  end

  defp valid_schedule?("195", _, 0) do
    # only inbound trips
    false
  end

  defp valid_schedule?(id, date, _) when id in @weekday_only_routes do
    weekday?(date)
  end

  defp valid_schedule?(_route_id, _date, _direction_id) do
    true
  end

  defp receive_items(module) do
    clear_inbox!()

    receive do
      {:event, {:new_state, ^module}, items, _} when items > 0 ->
        :ok
    end
  end

  defp clear_inbox! do
    receive do
      _ ->
        clear_inbox!()
    after
      0 ->
        :ok
    end
  end

  defp assert_first_last_stop_id(route_id, first_stop_id, last_stop_id) do
    assert {%{id: ^first_stop_id}, %{id: ^last_stop_id}} = first_last(stops(route_id, 0))
    assert {%{id: ^last_stop_id}, %{id: ^first_stop_id}} = first_last(stops(route_id, 1))
  end

  defp all_routes do
    State.Route.all(order_by: {:sort_order, :asc})
  end

  defp stops(route_id, direction_id) do
    State.Stop.filter_by(%{routes: [route_id], direction_id: direction_id})
  end

  defp dates_of_rating do
    {:ok, feed} = State.Feed.get()

    for dt <-
          Timex.Interval.new(
            from: Parse.Time.service_date(),
            until: feed.end_date,
            right_open: false
          ) do
      NaiveDateTime.to_date(dt)
    end
  end

  for date <- Application.get_env(:state_mediator, GtfsTest)[:custom_dates] do
    defp custom_date?(unquote(Macro.escape(date))), do: true
  end

  defp custom_date?(_), do: false

  defp exempt_from_testing?(route)

  for route_id <- Application.get_env(:state_mediator, GtfsTest)[:routes_exempt_from_testing] do
    defp exempt_from_testing?(%{id: unquote(route_id)}), do: true
  end

  defp exempt_from_testing?(route), do: State.Route.hidden?(route)

  defp first_last([first | rest]) do
    {first, List.last(rest)}
  end

  defp weekday?(date) do
    Date.day_of_week(date) < 6
  end

  defp shapes_in_both_directions(route) do
    for direction_id <- 0..1 do
      [route]
      |> State.Shape.select_routes(direction_id)
      |> Enum.reject(&(&1.priority < 0))
    end
  end
end
